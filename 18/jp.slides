â€º Perl est Sympatic

    JournÃ©es Perl 2018

    https://github.com/eiro/slides.vim
    https://github.com/eiro/talks/blob/master/18/jp.slides
    Marc Chantreux
    Les questions sur #mongueurs@irc.perl.org

â€º Renater

    NREN (National Research and Education Network)
    France

â€º Renater et le libre

    î€‹ Sympa
    î€‹ FileSender
    î€‹ Moment
    î€‹ Jitsi
    î€‹ ...

â€º l'Ã©tat et le libre

 î€‹ loi nÂ° 2016-1321 du 7 octobre 2016
   pour une RÃ©publique numÃ©rique (lÃ©gifrance)
 î€‹ Thinkerview de Mounir Hajoubi
   https://thinkerview.com/mounir-mahjoubi-ministre-charge-numerique/

â€º recommendations DISIC

   DISIC:
       Direction
       InterministÃ©rielle des
       SystÃ¨mes d'
       Information et de
       Communication

   https://disic.github.io/politique-de-contribution-open-source/

â€º Renater recrute

    https://www.renater.fr/emploi-stage

â€º A Renater

    î€‹ CommunautÃ© Sympa
    î€‹ Floss Evangelism

â€º Marc Chantreux

    î€‹ 2012: Gestion de Sympa Ã  Unistra
    î€‹ 2017: Hackathon 20Ã¨me anniversaire
    î€‹ 2017: Renater

â€º Sympa

    "Gestionnaire de listes et plus si affinitÃ©s"
    -- David Verdin, JournÃ©es Perl 2013

    "features ... too many of them to be described"
    -- David Verdin, YAPC2014

â€º Support et hosting

    î€‹ commercial support (linuxia, ...)
    î€‹ OW2 (open web consortium) en 2018
    î€‹ Renater (universalistes)
      Framasoft (framalistes)
      riseup ...

â€º Survey 2015

    1 message entrant toutes les 2 secondes
    (mondial)

â€º Sympa community

    â–¶ https://github.com/sympa-community/
    â–¶ freenode #sympa
    â–¶ freenode #sympa-fr
    â–¶ sympa-developpers(a t)listes.renater.fr
    â–¶ sympa-users(a t)listes.renater.fr
    â–¶ sympa-fr(a t)listes.renater.fr

â€º Sympa est vieux

    â–¶ Base de code
    â–¶ Interface web
    â–¶ Tooling

â€º Make "sympa great again"

    sympa est un moteur de rÃ©seau social

â€º Trouver des contributeurs

    â–¶ Perl semble Ãªtre un frein

â€º Perl bashing partout

  Pourtant

    â–¶ convergences des pratiques
    â–¶ Ã©volution de l'Ã©cosystÃ¨me perl
    â–¶ outils de base
    â–¶ unix devenu mainstream

â€º Python

    î€‹ PEP 448 -- Additional Unpacking Generalizations
    î€‹ PEP 498 -- Literal String Interpolation
    î€‹ PEP 572 -- Assignment Expressions

â€º Javascript

    for (x in xs) ys.push( x + 3 )

    ys = xs.map ( x => x + 3 )

â€º Javascript

    for (x in xs) ys.push( x + 3 )

    ys = xs.
        filter ( x => ).
        map ( x => x + 3 )

â€º Mais les mongueurs ?

    habitudes ont la tÃªte dure
    (pas que nous!)

â€º CPAN everywhere!

    Mutualiser au maximum
    î€‹ la maintenance
    î€‹ l'Ã©volution

â€º Un perl actuel

    î€‹ cacher le code "d'infrastructure"
    î€‹ cacher les piÃ¨ges et les internals
    î€‹ s'inspirer des autres langages dynamiques

â€º Les classiques

    î€‹  Dancer2, Moo, DBIx::Class ...
    î€‹  dzil, cpanm, plackup ...

â€º Boilerplate ?

    use strict;
    use warnings;

    # et surtout pas use 5.14!
    use feature qw< say state unicode_strings >;
    use open qw< :UTF-8  :std >;
    use utf8;

    # no_match_vars c'Ã©tait avant!
    use English qw<  -no_match_vars >;
    use Moo;
    ...

â€º Boilerplate ? (enable mode troll)

    use autodie;
    use Path::Tiny;
    use Perlude;
    ...

â€º use Sympatic

    le boilerplate officiel de sympa

â€º let's code

    package Counter
    î€‹ usage
    î€‹ implÃ©mentation(s)

â€º package Counter (usage)

    use Counter;
    use features qw< say >;
    my $counter = Counter->new(value => 3 );

    say $counter->value;   # 3
    say $counter->next;    # 4
    say $counter->next;    # 5
    say $counter->add(2);  # 7

â€º package Counter (implementation)

    package Counter;

    sub new {
        bless
            ( +{ qw( value 0) , @_ }
            , __PACKAGE__ );
    }

    sub value {
        my $self = shift;
        @_ or return $$self{value};
        $$self{value} = shift;
    }

    sub next { ++$_[0]->{value} }
    sub add  { ... }

â€º package Counter (moo)

    package Counter;
    use Moo;

    has qw( value is rw )
    , default => 0;

    sub next {
        my ( $self , $value ) = @_;
        $self->value( $self->value + 1 )
    }

    sub add { ... }

â€º Type checking ?

    has qw( value is rw )
    , default => 0
    , isa     => sub {
        die "$_ isn't a number" unless /^\d$/
    };


â€º Perl6

    subset Nat  of Int where * >= 0;
    subset Mois of Nat where * < 13;

î€‹ Type::Tiny permet de definir des subsets


â€º Type::Tiny permet de definir des subsets

    Type::Tiny ->new
        ( name       => "Number"
        , constraint => sub { looks_like_number($_) }
        , message    => sub { "$_ ain't a number" } );

â€º Types::Standard

    utilise Type::Tiny pour dÃ©finir des types standard

â€º

    Int, Str , ...

â€º

    Maybe[Str]
    ArrayRef[Str]
    InstanceOf['List']

â€º

    ArrayRef[ Maybe[ InstanceOf ['List']]]

â€º

    use Types::Standard qw< Int >;

    has qw( value is rw )
    , default => 0
    , isa     => Int;

â€º truc qui fache ...

    sub next {
        my ( $self , $value ) = @_;
        $self->value( $self->value + 1 )
    }

â€º mes bonnes vieilles habitudes

    Avant â”‚ $$self{value} += 2
    AprÃ¨s â”‚ $self->value( $self->value + 2 )

â€º Notation indirecte

    my $c = Counter->new;
    $c->value( 2 );

â€º equivaut Ã 

    Counter::value $c, 2;

â€º lvaluer un attribut ?

â€º lvalue ?

    man `perlsub`

â€º lvalue (crÃ©ation)

    {   my $val;
        sub counter :lvalue { $val }
    }

â€º lvalue (usage)

    (counter) //= 3;
    say ++counter; # 4

â€º comparons

    old school  â”ƒ ++$$self{value};
    Moo         â”ƒ $self->value( $self->value + 1 )
    lvalue      â”ƒ ++$self->value;

â€º let's go coding!

    ... ou alors ...

â€º let's go shopping!

    CPAN ğŸ˜


â€º MooX::LvalueAttribute

    package Counter;
    use Moo;
    use MooX::LvalueAttribute;
    use Types::Standard qw< Int >;

    has qw( value is rw )
    , default => 0
    , lvalue  => 1
    , isa     => Int;

    sub next { ++$_[0]->value }
    sub add  { ... }

â€º functions variadiques (@_)

    sub next { ++$_[0]->value }

â€º functions variadiques (@_)

    î€‹  utiles dans 2% des cas
    î€‹  pour le reste ...

â€º signatures

        (python, javascript, ruby, php ...)

â€º signatures

    î€‹ experimental depuis 5.20
    î€‹ acceptÃ© dans 5.26

â€º sauf que ...

    sympa doit supporter 5.16

â€º pluggable keywords: perl 5.12

    depuis perl 5.12

â€º Function::Parameters

  fun hello (Â $whoÂ ) {   â”ƒ  sub hello {
      say "hello $who";  â”ƒ     Â my ( $who ) = @_;Â 
  }                      â”ƒ      say "hello $who";
                         â”ƒ  }

â€º valeurs par defaut

    sub hello {
       Â my $who = @_ ? shift : "world";Â 
        say "hello $who";
    }

    â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

    fun hello (Â $who = 'world'Â ) {
        say "hello $who";
    }

â€º Type::* dans les signatures

    sub hello {
       Â my $who = @_ ? shift : "world";Â 
       Â ref $who and die "no reference allowed";Â 
        say "hello $who";
    }
    â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    use Types::Standard qw< Str >;

    fun hello (Â Str $who = 'world'Â ) {
        say "hello $who";
    }

â€º more ...

    fun greetings ( Str $name = $ENV{USER} // 'world' ) {
        say "hello $name"
    }
    greetings "program";

â€º Methodes

    Â funÂ next (Â $selfÂ ) { ++$self->value }
    â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    Â methodÂ next () { ++$self->value }

â€º la methode add (moo)

    sub add {
        die unless @_ == 2;
        my ($self, $int ) = @_;
        die unless looks_like_number $int;
        $self->value += Int->($int);
    }
    â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    method add ( Int $x ) { $self->value += $x }

â€º convention

    î€‹ fun : methodes privÃ©es
    î€‹ method for public methods

â€º version finale

    package Counter;
    use Sympatic;
    use Types::Standard qw< Int >;

    has qw( value is rw )
    , default => 0
    , lvalue  => 1
    , isa     => Int;

    method next { ++$self->value }
    method ( Int $add ) { $self->value += $add }

â€º en rÃ©alitÃ© ...

    besoin de plus

â€º boilerplate

    package Counter;
    use Moo;
    use MooX::LvalueAttribute;
    use strict;
    use warnings;
    use feature qw< say >;
    use English qw<  -no_match_vars >;
    use autodie;
    use Function::Parameters;
    use Types::Standard qw< Int >;

â€º Sympatic

    package Counter;
    use Sympatic;
    use Types::Standard qw< Int >;

â€º Sympatic

    î€‹ moins de code
    î€‹ moins de useless bugs
    î€‹ moins de recherche sur CPAN

â€º Sympatic

    î€‹ plus de documentation
    î€‹ plus de tests
    î€‹ plus de consistency

â€º Sympatic

    î€‹ superset de perl connu des contributeurs
    î€‹ syntaxe dÃ©clarative


â€º contactez nous

* david.verdin[at]renater.fr
* marc.chantreux[at]renater.fr
* sympa-users[at]listes.renater.fr
* sympa-developpers[at]listes.renater.fr

â€º questions

â€º extra slides

â€º use 5.14

    juste non: ~~ + given = depreciÃ©

â€º rÃ©peter sans cesse et oublier

    chdir $spool
        or die "$! while chdir('$spool')";
    open my $fh,'>',"index.txt"
        or die "$! while open('index.txt')";
    chdir $cwd
        or die "$! while chdir('$cwd')";

â€º ou pas ...

    use autodie;

    chdir $spool;
    open my $fh,'>',"index.txt";
    chdir $cwd;

â€º autodie

    l'oublie pas de mourir

â€º c'est quoi Ã§a ?

    print $(

â€º mÃ©moriser ...

    man `perlvar` par coeur ?

â€º ou  ...

    avoir des noms de variables parlants

    use English qw<  -no_match_vars >;
    print $GID


â€º pseudo cyclomatic complexity removal

    if ( $foo < 10 )     { die "need more" }
    elsif ( $foo < 100 ) { return $foo     }
    else                 { return 100      }
    â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    $foo < 10     and die "need more";
    $foo < 100    and return $foo;
    100;

â€º what does this code ?

    my $user;
    my $fake_it = $config->is_fake;

    if ( $fake_it ) {
        logging info => "fake user provided";
        $user = 0;
    }
    else {
        logging info => "real user $UID provided";
        $user = $UID;
    }

â€º it initialize $user

    myÂ $user;Â 
    my $fake_it = $config->is_fake;

    if ( $fake_it ) {
        logging info => "fake user provided";
       Â $userÂ = 0;
    }
    else {
        logging info => "real user $UID provided";
       Â $userÂ = $UID;
    }

â€º in ruby

    ruby
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    w = 3
    x = if w > 2
            then
               Â puts "hello world"Â 
                if 3 == 3 then 3 else 4
            end
        else
            0
        end
    puts x

â€º other langages

    ruby
    python
    javascript
    livescript
    haskell
    elm
    ...

â€º do makes it obvious

    myÂ $userÂ = do {
        my $fake_it = $config->is_fake;
        if ( $fake_it ) {
            logging info => "fake user provided";
           Â 0;Â 
        }
        else {
            logging info => "real user $UID provided";
           Â $UID;Â 
        }
    };

â€º Â doÂ  creates


â€º Path::Tiny + List::AllUtils

    my $file =
        first { -e ? path($_) : () }
        qw( those candidates for configuration );


â€º Historique

   î€‹ basÃ©e sur la conf. fosdem 2018
   î€‹ prÃ©sentÃ©e
       î€‹ aux journÃ©es perl 2018
       î€‹ au hackathon sympa 2018
   î€‹ base pour
       î€‹ the perl conference europe 2018















â€º 

â€º 

â€º 

â€º 

â€º 

â€º 

â€º 


